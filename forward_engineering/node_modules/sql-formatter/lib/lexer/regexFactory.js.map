{"version":3,"file":"regexFactory.js","names":["lineComment","lineCommentTypes","RegExp","map","escapeRegExp","join","parenthesis","kind","extraParens","index","parens","pair","patternToRegex","operator","monadOperators","polyadOperators","sortByLengthDesc","split","rejectIdentCharsPattern","rest","dashes","reservedWord","reservedKeywords","identChars","length","avoidIdentChars","reservedKeywordsPattern","replace","parameter","paramTypes","pattern","undefined","typesRegex","buildQStringPatterns","specialDelimiterMap","singlePattern","patternList","Object","entries","left","right","specialDelimiters","keys","standardDelimiterPattern","String","raw","qStringPattern","quotePatterns","singleQuotePattern","quoteTypes","prefixesPattern","quote","variable","varTypes","varType","regex","stringPattern","string","identifier","specialChars","identifierPattern","first","allowFirstCharNumber","letter","number","firstChars","restChars","withDashes"],"sources":["../../src/lexer/regexFactory.ts"],"sourcesContent":["import { sortByLengthDesc } from 'src/utils';\n\nimport type { IdentChars, QuoteType, VariableType } from './TokenizerOptions';\nimport { escapeRegExp, patternToRegex, prefixesPattern, withDashes } from './regexUtil';\n\n/**\n * Builds a RegExp for valid line comments in a SQL dialect\n * @param {string[]} lineCommentTypes - list of character strings that denote line comments\n */\nexport const lineComment = (lineCommentTypes: string[]) =>\n  new RegExp(`(?:${lineCommentTypes.map(escapeRegExp).join('|')}).*?(?=\\r\\n|\\r|\\n|$)`, 'uy');\n\n/**\n * Builds a RegExp for matching either open- or close-parenthesis patterns\n */\nexport const parenthesis = (kind: 'open' | 'close', extraParens: ('[]' | '{}')[] = []): RegExp => {\n  const index = kind === 'open' ? 0 : 1;\n  const parens = ['()', ...extraParens].map(pair => pair[index]);\n  return patternToRegex(parens.map(escapeRegExp).join('|'));\n};\n\n/**\n * Builds a RegExp containing all operators for a SQL dialect\n * @param {string} monadOperators - concatenated string of all 1-length operators\n * @param {string[]} polyadOperators - list of strings of all >1-length operators\n */\nexport const operator = (monadOperators: string, polyadOperators: string[]) =>\n  patternToRegex(\n    `${sortByLengthDesc(polyadOperators).map(escapeRegExp).join('|')}|` +\n      `[${monadOperators.split('').map(escapeRegExp).join('')}]`\n  );\n\n// Negative lookahead to avoid matching a keyword that's actually part of identifier,\n// which can happen when identifier allows word-boundary characters inside it.\n//\n// For example \"SELECT$ME\" should be tokenized as:\n// - [\"SELECT$ME\"] when $ is allowed inside identifiers\n// - [\"SELECT\", \"$\", \"ME\"] when $ can't be part of identifiers.\nconst rejectIdentCharsPattern = ({ rest, dashes }: IdentChars): string =>\n  rest || dashes ? `(?![${rest || ''}${dashes ? '-' : ''}])` : '';\n\n/**\n * Builds a RegExp for all Reserved Keywords in a SQL dialect\n */\nexport const reservedWord = (reservedKeywords: string[], identChars: IdentChars = {}): RegExp => {\n  if (reservedKeywords.length === 0) {\n    return /^\\b$/u;\n  }\n\n  const avoidIdentChars = rejectIdentCharsPattern(identChars);\n\n  const reservedKeywordsPattern = sortByLengthDesc(reservedKeywords)\n    .join('|')\n    .replace(/ /gu, '\\\\s+');\n\n  return new RegExp(`(?:${reservedKeywordsPattern})${avoidIdentChars}\\\\b`, 'iuy');\n};\n\n/**\n * Builds a RegExp for parameter placeholder patterns\n * @param {string[]} paramTypes - list of strings that denote placeholder types\n * @param {string} pattern - string that denotes placeholder pattern\n */\nexport const parameter = (paramTypes: string[], pattern: string): RegExp | undefined => {\n  if (!paramTypes.length) {\n    return undefined;\n  }\n  const typesRegex = paramTypes.map(escapeRegExp).join('|');\n\n  return patternToRegex(`(?:${typesRegex})(?:${pattern})`);\n};\n\nconst buildQStringPatterns = () => {\n  const specialDelimiterMap = {\n    '<': '>',\n    '[': ']',\n    '(': ')',\n    '{': '}',\n  };\n\n  // base pattern for special delimiters, left must correspond with right\n  const singlePattern = \"{left}(?:(?!{right}').)*?{right}\";\n\n  // replace {left} and {right} with delimiters, collect as array\n  const patternList = Object.entries(specialDelimiterMap).map(([left, right]) =>\n    singlePattern.replace(/{left}/g, escapeRegExp(left)).replace(/{right}/g, escapeRegExp(right))\n  );\n\n  const specialDelimiters = escapeRegExp(Object.keys(specialDelimiterMap).join(''));\n  // standard pattern for common delimiters, ignores special delimiters\n  const standardDelimiterPattern = String.raw`(?<tag>[^\\s${specialDelimiters}])(?:(?!\\k<tag>').)*?\\k<tag>`;\n\n  // constructs final pattern by joining all cases\n  const qStringPattern = `[Qq]'(?:${standardDelimiterPattern}|${patternList.join('|')})'`;\n\n  return qStringPattern;\n};\n\n// This enables the following quote styles:\n// 1. backtick quoted using `` to escape\n// 2. square bracket quoted (SQL Server) using ]] to escape\n// 3. double quoted using \"\" or \\\" to escape\n// 4. single quoted using '' or \\' to escape\n// 5. PostgreSQL dollar-quoted\n// 6. BigQuery '''triple-quoted'''\n// 7. BigQuery \"\"\"triple-quoted\"\"\"\n// 8. Hive and Spark variables: ${name}\n// 9. Oracle q'' strings: q'<text>' q'|text|' ...\nexport const quotePatterns = {\n  '``': '(?:`[^`]*(?:$|`))+',\n  '[]': String.raw`(?:\\[[^\\]]*(?:$|\\]))(?:\\][^\\]]*(?:$|\\]))*`,\n  '\"\"': String.raw`(?:\"[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*(?:\"|$))+`,\n  \"''\": String.raw`(?:'[^'\\\\]*(?:\\\\.[^'\\\\]*)*(?:'|$))+`,\n  '$$': String.raw`(?<tag>\\$\\w*\\$)[\\s\\S]*?(?:\\k<tag>|$)`,\n  \"'''..'''\": String.raw`'''[^\\\\]*?(?:\\\\.[^\\\\]*?)*?(?:'''|$)`,\n  '\"\"\"..\"\"\"': String.raw`\"\"\"[^\\\\]*?(?:\\\\.[^\\\\]*?)*?(?:\"\"\"|$)`,\n  '{}': String.raw`(?:\\{[^\\}]*(?:$|\\}))`,\n  \"q''\": buildQStringPatterns(),\n};\n\nconst singleQuotePattern = (quoteTypes: QuoteType): string => {\n  if (typeof quoteTypes === 'string') {\n    return quotePatterns[quoteTypes];\n  } else {\n    return prefixesPattern(quoteTypes) + quotePatterns[quoteTypes.quote];\n  }\n};\n\n/** Builds a RegExp for matching variables */\nexport const variable = (varTypes: VariableType[]): RegExp =>\n  patternToRegex(\n    varTypes\n      .map(varType => ('regex' in varType ? varType.regex : singleQuotePattern(varType)))\n      .join('|')\n  );\n\n/** Builds a quote-delimited pattern for matching all given quote types */\nexport const stringPattern = (quoteTypes: QuoteType[]): string =>\n  quoteTypes.map(singleQuotePattern).join('|');\n\n/** Builds a RegExp for matching quote-delimited patterns */\nexport const string = (quoteTypes: QuoteType[]): RegExp =>\n  patternToRegex(stringPattern(quoteTypes));\n\n/**\n * Builds a RegExp for valid identifiers in a SQL dialect\n */\nexport const identifier = (specialChars: IdentChars = {}): RegExp =>\n  patternToRegex(identifierPattern(specialChars));\n\n/**\n * Builds a RegExp string for valid identifiers in a SQL dialect\n */\nexport const identifierPattern = ({\n  first,\n  rest,\n  dashes,\n  allowFirstCharNumber,\n}: IdentChars = {}): string => {\n  // Unicode letters, diacritical marks and underscore\n  const letter = '\\\\p{Alphabetic}\\\\p{Mark}_';\n  // Numbers 0..9, plus various unicode numbers\n  const number = '\\\\p{Decimal_Number}';\n\n  const firstChars = escapeRegExp(first ?? '');\n  const restChars = escapeRegExp(rest ?? '');\n\n  const pattern = allowFirstCharNumber\n    ? `[${letter}${number}${firstChars}][${letter}${number}${restChars}]*`\n    : `[${letter}${firstChars}][${letter}${number}${restChars}]*`;\n\n  return dashes ? withDashes(pattern) : pattern;\n};\n"],"mappings":"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"}