{"version":3,"file":"token.js","names":["TokenType","EOF_TOKEN","type","EOF","raw","text","start","Infinity","end","testToken","compareToken","token","isToken","ARRAY","RESERVED_KEYWORD","BY","SET","RESERVED_COMMAND","STRUCT","WINDOW","isReserved","RESERVED_FUNCTION_NAME","RESERVED_PHRASE","RESERVED_DEPENDENT_CLAUSE","RESERVED_SELECT","RESERVED_SET_OPERATION","RESERVED_JOIN","ARRAY_KEYWORD","CASE","END","LIMIT","BETWEEN","AND","OR","XOR","isParameter","NUMBERED_PARAMETER","NAMED_PARAMETER","POSITIONAL_PARAMETER","QUOTED_PARAMETER","isLogicalOperator"],"sources":["../../src/lexer/token.ts"],"sourcesContent":["/** Token type enum for all possible Token categories */\nexport enum TokenType {\n  QUOTED_IDENTIFIER = 'QUOTED_IDENTIFIER',\n  IDENTIFIER = 'IDENTIFIER',\n  STRING = 'STRING',\n  VARIABLE = 'VARIABLE',\n  RESERVED_KEYWORD = 'RESERVED_KEYWORD',\n  RESERVED_FUNCTION_NAME = 'RESERVED_FUNCTION_NAME',\n  RESERVED_PHRASE = 'RESERVED_PHRASE',\n  RESERVED_DEPENDENT_CLAUSE = 'RESERVED_DEPENDENT_CLAUSE',\n  RESERVED_SET_OPERATION = 'RESERVED_SET_OPERATION',\n  RESERVED_COMMAND = 'RESERVED_COMMAND',\n  RESERVED_SELECT = 'RESERVED_SELECT',\n  RESERVED_JOIN = 'RESERVED_JOIN',\n  ARRAY_IDENTIFIER = 'ARRAY_IDENTIFIER', // IDENTIFIER token in front of [\n  ARRAY_KEYWORD = 'ARRAY_KEYWORD', // RESERVED_KEYWORD token in front of [\n  CASE = 'CASE',\n  END = 'END',\n  LIMIT = 'LIMIT',\n  BETWEEN = 'BETWEEN',\n  AND = 'AND',\n  OR = 'OR',\n  XOR = 'XOR',\n  OPERATOR = 'OPERATOR',\n  COMMA = 'COMMA',\n  ASTERISK = 'ASTERISK', // *\n  OPEN_PAREN = 'OPEN_PAREN',\n  CLOSE_PAREN = 'CLOSE_PAREN',\n  LINE_COMMENT = 'LINE_COMMENT',\n  BLOCK_COMMENT = 'BLOCK_COMMENT',\n  NUMBER = 'NUMBER',\n  NAMED_PARAMETER = 'NAMED_PARAMETER',\n  QUOTED_PARAMETER = 'QUOTED_PARAMETER',\n  NUMBERED_PARAMETER = 'NUMBERED_PARAMETER',\n  POSITIONAL_PARAMETER = 'POSITIONAL_PARAMETER',\n  DELIMITER = 'DELIMITER',\n  EOF = 'EOF',\n}\n\n/** Struct to store the most basic cohesive unit of language grammar */\nexport interface Token {\n  type: TokenType;\n  raw: string; // The raw original text that was matched\n  text: string; // Cleaned up text e.g. keyword converted to uppercase and extra spaces removed\n  key?: string;\n  start: number; // 0-based index of the token in the whole query string\n  end: number; // 0-based index of where the token ends in the query string\n  precedingWhitespace?: string; // Whitespace before this token, if any\n}\n\n/**\n * For use as a \"missing token\"\n * e.g. in lookAhead and lookBehind to avoid dealing with null values\n */\nexport const EOF_TOKEN: Token = {\n  type: TokenType.EOF,\n  raw: '«EOF»',\n  text: '«EOF»',\n  start: Infinity,\n  end: Infinity,\n};\n\n/** Checks if two tokens are equivalent */\nexport const testToken =\n  (compareToken: { type: TokenType; text: string }) =>\n  (token: Token): boolean =>\n    token.type === compareToken.type && token.text === compareToken.text;\n\n/** Util object that allows for easy checking of Reserved Keywords */\nexport const isToken = {\n  ARRAY: testToken({ text: 'ARRAY', type: TokenType.RESERVED_KEYWORD }),\n  BY: testToken({ text: 'BY', type: TokenType.RESERVED_KEYWORD }),\n  SET: testToken({ text: 'SET', type: TokenType.RESERVED_COMMAND }),\n  STRUCT: testToken({ text: 'STRUCT', type: TokenType.RESERVED_KEYWORD }),\n  WINDOW: testToken({ text: 'WINDOW', type: TokenType.RESERVED_COMMAND }),\n};\n\n/** Checks if token is any Reserved Keyword or Command */\nexport const isReserved = (token: Token): boolean =>\n  token.type === TokenType.RESERVED_KEYWORD ||\n  token.type === TokenType.RESERVED_FUNCTION_NAME ||\n  token.type === TokenType.RESERVED_PHRASE ||\n  token.type === TokenType.RESERVED_DEPENDENT_CLAUSE ||\n  token.type === TokenType.RESERVED_COMMAND ||\n  token.type === TokenType.RESERVED_SELECT ||\n  token.type === TokenType.RESERVED_SET_OPERATION ||\n  token.type === TokenType.RESERVED_JOIN ||\n  token.type === TokenType.ARRAY_KEYWORD ||\n  token.type === TokenType.CASE ||\n  token.type === TokenType.END ||\n  token.type === TokenType.LIMIT ||\n  token.type === TokenType.BETWEEN ||\n  token.type === TokenType.AND ||\n  token.type === TokenType.OR ||\n  token.type === TokenType.XOR;\n\n/** checks if token is one of the parameter tokens */\nexport const isParameter = (token: Token): boolean =>\n  token.type === TokenType.NUMBERED_PARAMETER ||\n  token.type === TokenType.NAMED_PARAMETER ||\n  token.type === TokenType.POSITIONAL_PARAMETER ||\n  token.type === TokenType.QUOTED_PARAMETER;\n\nexport const isLogicalOperator = (token: Token): boolean =>\n  token.type === TokenType.AND || token.type === TokenType.OR || token.type === TokenType.XOR;\n"],"mappings":"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"}