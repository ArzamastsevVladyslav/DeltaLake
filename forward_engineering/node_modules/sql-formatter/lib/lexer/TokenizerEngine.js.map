{"version":3,"file":"TokenizerEngine.js","names":["TokenizerEngine","rules","input","index","tokens","token","length","precedingWhitespace","getWhitespace","getNextToken","Error","slice","push","WHITESPACE_REGEX","lastIndex","matches","exec","undefined","rule","match","regex","matchedText","type","raw","text","start","end","key"],"sources":["../../src/lexer/TokenizerEngine.ts"],"sourcesContent":["import { Token, TokenType } from 'src/lexer/token';\nimport { WHITESPACE_REGEX } from './regexUtil';\n\nexport interface RegExpLike {\n  lastIndex: number;\n  exec(input: string): string[] | null;\n}\n\nexport interface TokenRule {\n  type: TokenType;\n  // Normally a RegExp object.\n  // But to allow for more complex matching logic,\n  // an object can be given that implements a RegExpLike interface.\n  regex: RegExpLike;\n  // Called with the raw string that was matched\n  text?: (rawText: string) => string;\n  key?: (rawText: string) => string;\n}\n\nexport default class TokenizerEngine {\n  private input = ''; // The input SQL string to process\n  private index = 0; // Current position in string\n\n  constructor(private rules: TokenRule[]) {}\n\n  /**\n   * Takes a SQL string and breaks it into tokens.\n   * Each token is an object with type and value.\n   *\n   * @param {string} input - The SQL string\n   * @returns {Token[]} output token stream\n   */\n  public tokenize(input: string): Token[] {\n    this.input = input;\n    this.index = 0;\n    const tokens: Token[] = [];\n    let token: Token | undefined;\n\n    // Keep processing the string until end is reached\n    while (this.index < this.input.length) {\n      // skip any preceding whitespace\n      const precedingWhitespace = this.getWhitespace();\n\n      if (this.index < this.input.length) {\n        // Get the next token and the token type\n        token = this.getNextToken();\n        if (!token) {\n          throw new Error(`Parse error: Unexpected \"${input.slice(this.index, 100)}\"`);\n        }\n\n        tokens.push({ ...token, precedingWhitespace });\n      }\n    }\n    return tokens;\n  }\n\n  private getWhitespace(): string | undefined {\n    WHITESPACE_REGEX.lastIndex = this.index;\n\n    const matches = WHITESPACE_REGEX.exec(this.input);\n    if (matches) {\n      // Advance current position by matched whitespace length\n      this.index += matches[0].length;\n      return matches[0];\n    }\n    return undefined;\n  }\n\n  private getNextToken(): Token | undefined {\n    for (const rule of this.rules) {\n      const token = this.match(rule);\n      if (token) {\n        return token;\n      }\n    }\n    return undefined;\n  }\n\n  // Attempts to match token rule regex at current position in input\n  private match(rule: TokenRule): Token | undefined {\n    rule.regex.lastIndex = this.index;\n    const matches = rule.regex.exec(this.input);\n    if (matches) {\n      const matchedText = matches[0];\n\n      const token: Token = {\n        type: rule.type,\n        raw: matchedText,\n        text: rule.text ? rule.text(matchedText) : matchedText,\n        start: this.index,\n        end: this.index + matchedText.length,\n      };\n\n      if (rule.key) {\n        token.key = rule.key(matchedText);\n      }\n\n      // Advance current position by matched token length\n      this.index += matchedText.length;\n      return token;\n    }\n    return undefined;\n  }\n}\n"],"mappings":";;;;;;;AACA;;;;;;;;;;;;;;;;;;;;IAkBqBA,e;EACC;EACD;EAEnB,yBAAoBC,KAApB,EAAwC;IAAA;;IAAA,KAApBA,KAAoB,GAApBA,KAAoB;;IAAA,+BAHxB,EAGwB;;IAAA,+BAFxB,CAEwB;EAAE;EAE1C;AACF;AACA;AACA;AACA;AACA;AACA;;;;;WACE,kBAAgBC,KAAhB,EAAwC;MACtC,KAAKA,KAAL,GAAaA,KAAb;MACA,KAAKC,KAAL,GAAa,CAAb;MACA,IAAMC,MAAe,GAAG,EAAxB;MACA,IAAIC,KAAJ,CAJsC,CAMtC;;MACA,OAAO,KAAKF,KAAL,GAAa,KAAKD,KAAL,CAAWI,MAA/B,EAAuC;QACrC;QACA,IAAMC,mBAAmB,GAAG,KAAKC,aAAL,EAA5B;;QAEA,IAAI,KAAKL,KAAL,GAAa,KAAKD,KAAL,CAAWI,MAA5B,EAAoC;UAClC;UACAD,KAAK,GAAG,KAAKI,YAAL,EAAR;;UACA,IAAI,CAACJ,KAAL,EAAY;YACV,MAAM,IAAIK,KAAJ,qCAAsCR,KAAK,CAACS,KAAN,CAAY,KAAKR,KAAjB,EAAwB,GAAxB,CAAtC,QAAN;UACD;;UAEDC,MAAM,CAACQ,IAAP,iCAAiBP,KAAjB;YAAwBE,mBAAmB,EAAnBA;UAAxB;QACD;MACF;;MACD,OAAOH,MAAP;IACD;;;WAED,yBAA4C;MAC1CS,2BAAA,CAAiBC,SAAjB,GAA6B,KAAKX,KAAlC;;MAEA,IAAMY,OAAO,GAAGF,2BAAA,CAAiBG,IAAjB,CAAsB,KAAKd,KAA3B,CAAhB;;MACA,IAAIa,OAAJ,EAAa;QACX;QACA,KAAKZ,KAAL,IAAcY,OAAO,CAAC,CAAD,CAAP,CAAWT,MAAzB;QACA,OAAOS,OAAO,CAAC,CAAD,CAAd;MACD;;MACD,OAAOE,SAAP;IACD;;;WAED,wBAA0C;MAAA,2CACrB,KAAKhB,KADgB;MAAA;;MAAA;QACxC,oDAA+B;UAAA,IAApBiB,IAAoB;UAC7B,IAAMb,KAAK,GAAG,KAAKc,KAAL,CAAWD,IAAX,CAAd;;UACA,IAAIb,KAAJ,EAAW;YACT,OAAOA,KAAP;UACD;QACF;MANuC;QAAA;MAAA;QAAA;MAAA;;MAOxC,OAAOY,SAAP;IACD,C,CAED;;;;WACA,eAAcC,IAAd,EAAkD;MAChDA,IAAI,CAACE,KAAL,CAAWN,SAAX,GAAuB,KAAKX,KAA5B;MACA,IAAMY,OAAO,GAAGG,IAAI,CAACE,KAAL,CAAWJ,IAAX,CAAgB,KAAKd,KAArB,CAAhB;;MACA,IAAIa,OAAJ,EAAa;QACX,IAAMM,WAAW,GAAGN,OAAO,CAAC,CAAD,CAA3B;QAEA,IAAMV,KAAY,GAAG;UACnBiB,IAAI,EAAEJ,IAAI,CAACI,IADQ;UAEnBC,GAAG,EAAEF,WAFc;UAGnBG,IAAI,EAAEN,IAAI,CAACM,IAAL,GAAYN,IAAI,CAACM,IAAL,CAAUH,WAAV,CAAZ,GAAqCA,WAHxB;UAInBI,KAAK,EAAE,KAAKtB,KAJO;UAKnBuB,GAAG,EAAE,KAAKvB,KAAL,GAAakB,WAAW,CAACf;QALX,CAArB;;QAQA,IAAIY,IAAI,CAACS,GAAT,EAAc;UACZtB,KAAK,CAACsB,GAAN,GAAYT,IAAI,CAACS,GAAL,CAASN,WAAT,CAAZ;QACD,CAbU,CAeX;;;QACA,KAAKlB,KAAL,IAAckB,WAAW,CAACf,MAA1B;QACA,OAAOD,KAAP;MACD;;MACD,OAAOY,SAAP;IACD"}