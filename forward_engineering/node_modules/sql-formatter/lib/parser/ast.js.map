{"version":3,"file":"ast.js","names":["NodeType"],"sources":["../../src/parser/ast.ts"],"sourcesContent":["import { TokenType } from 'src/lexer/token';\n\nexport enum NodeType {\n  statement = 'statement',\n  clause = 'clause',\n  set_operation = 'set_operation',\n  function_call = 'function_call',\n  array_subscript = 'array_subscript',\n  property_access = 'property_access',\n  parenthesis = 'parenthesis',\n  between_predicate = 'between_predicate',\n  limit_clause = 'limit_clause',\n  all_columns_asterisk = 'all_columns_asterisk',\n  literal = 'literal',\n  identifier = 'identifier',\n  keyword = 'keyword',\n  parameter = 'parameter',\n  operator = 'operator',\n  comma = 'comma',\n  line_comment = 'line_comment',\n  block_comment = 'block_comment',\n}\n\nexport type StatementNode = {\n  type: NodeType.statement;\n  children: AstNode[];\n  hasSemicolon: boolean;\n};\n\nexport type ClauseNode = {\n  type: NodeType.clause;\n  name: KeywordNode;\n  children: AstNode[];\n};\n\nexport type SetOperationNode = {\n  type: NodeType.set_operation;\n  name: KeywordNode;\n  children: AstNode[];\n};\n\nexport type FunctionCallNode = {\n  type: NodeType.function_call;\n  name: KeywordNode;\n  parenthesis: ParenthesisNode;\n};\n\n// <ident>[<expr>]\nexport type ArraySubscriptNode = {\n  type: NodeType.array_subscript;\n  array: IdentifierNode | KeywordNode;\n  parenthesis: ParenthesisNode;\n};\n\nexport type ParenthesisNode = {\n  type: NodeType.parenthesis;\n  children: AstNode[];\n  openParen: string;\n  closeParen: string;\n};\n\n// BETWEEN <expr1> AND <expr2>\nexport type BetweenPredicateNode = {\n  type: NodeType.between_predicate;\n  between: KeywordNode;\n  expr1: AstNode[];\n  and: KeywordNode;\n  expr2: AstNode[];\n};\n\n// LIMIT <count>\n// LIMIT <offset>, <count>\nexport type LimitClauseNode = {\n  type: NodeType.limit_clause;\n  name: KeywordNode;\n  count: AstNode[];\n  offset?: AstNode[];\n};\n\n// The \"*\" operator used in SELECT *\nexport type AllColumnsAsteriskNode = {\n  type: NodeType.all_columns_asterisk;\n};\n\nexport type LiteralNode = {\n  type: NodeType.literal;\n  text: string;\n};\n\nexport type PropertyAccessNode = {\n  type: NodeType.property_access;\n  object: AstNode;\n  property: IdentifierNode | ArraySubscriptNode | AllColumnsAsteriskNode;\n};\n\nexport type IdentifierNode = {\n  type: NodeType.identifier;\n  text: string;\n};\n\nexport type KeywordNode = {\n  type: NodeType.keyword;\n  tokenType: TokenType;\n  text: string;\n  raw: string;\n};\n\nexport type ParameterNode = {\n  type: NodeType.parameter;\n  key?: string;\n  text: string;\n};\n\nexport type OperatorNode = {\n  type: NodeType.operator;\n  text: string;\n};\n\nexport type CommaNode = {\n  type: NodeType.comma;\n};\n\nexport type LineCommentNode = {\n  type: NodeType.line_comment;\n  text: string;\n  precedingWhitespace: string;\n};\n\nexport type BlockCommentNode = {\n  type: NodeType.block_comment;\n  text: string;\n};\n\nexport type AstNode =\n  | ClauseNode\n  | SetOperationNode\n  | FunctionCallNode\n  | ArraySubscriptNode\n  | PropertyAccessNode\n  | ParenthesisNode\n  | BetweenPredicateNode\n  | LimitClauseNode\n  | AllColumnsAsteriskNode\n  | LiteralNode\n  | IdentifierNode\n  | KeywordNode\n  | ParameterNode\n  | OperatorNode\n  | CommaNode\n  | LineCommentNode\n  | BlockCommentNode;\n"],"mappings":";;;;;;IAEYA,Q;;;WAAAA,Q;EAAAA,Q;EAAAA,Q;EAAAA,Q;EAAAA,Q;EAAAA,Q;EAAAA,Q;EAAAA,Q;EAAAA,Q;EAAAA,Q;EAAAA,Q;EAAAA,Q;EAAAA,Q;EAAAA,Q;EAAAA,Q;EAAAA,Q;EAAAA,Q;EAAAA,Q;EAAAA,Q;GAAAA,Q,wBAAAA,Q"}