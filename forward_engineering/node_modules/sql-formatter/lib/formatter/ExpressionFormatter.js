"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _utils = require("../utils");

var _config = require("./config");

var _token = require("../lexer/token");

var _ast = require("../parser/ast");

var _InlineBlock = _interopRequireDefault(require("./InlineBlock"));

var _Layout = require("./Layout");

var _tabularStyle = _interopRequireWildcard(require("./tabularStyle"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/** Formats a generic SQL expression */
var ExpressionFormatter = /*#__PURE__*/function () {
  function ExpressionFormatter(_ref) {
    var cfg = _ref.cfg,
        params = _ref.params,
        layout = _ref.layout,
        _ref$inline = _ref.inline,
        inline = _ref$inline === void 0 ? false : _ref$inline;

    _classCallCheck(this, ExpressionFormatter);

    _defineProperty(this, "cfg", void 0);

    _defineProperty(this, "inlineBlock", void 0);

    _defineProperty(this, "params", void 0);

    _defineProperty(this, "layout", void 0);

    _defineProperty(this, "inline", false);

    _defineProperty(this, "nodes", []);

    _defineProperty(this, "index", -1);

    this.cfg = cfg;
    this.inline = inline;
    this.inlineBlock = new _InlineBlock["default"](this.cfg.expressionWidth);
    this.params = params;
    this.layout = layout;
  }

  _createClass(ExpressionFormatter, [{
    key: "format",
    value: function format(nodes) {
      this.nodes = nodes;

      for (this.index = 0; this.index < this.nodes.length; this.index++) {
        var node = this.nodes[this.index];

        switch (node.type) {
          case _ast.NodeType.function_call:
            this.formatFunctionCall(node);
            break;

          case _ast.NodeType.array_subscript:
            this.formatArraySubscript(node);
            break;

          case _ast.NodeType.parenthesis:
            this.formatParenthesis(node);
            break;

          case _ast.NodeType.between_predicate:
            this.formatBetweenPredicate(node);
            break;

          case _ast.NodeType.clause:
            this.formatClause(node);
            break;

          case _ast.NodeType.set_operation:
            this.formatSetOperation(node);
            break;

          case _ast.NodeType.limit_clause:
            this.formatLimitClause(node);
            break;

          case _ast.NodeType.all_columns_asterisk:
            this.formatAllColumnsAsterisk(node);
            break;

          case _ast.NodeType.token:
            this.formatToken(node.token);
            break;
        }
      }

      return this.layout;
    }
  }, {
    key: "formatFunctionCall",
    value: function formatFunctionCall(node) {
      this.layout.add(this.show(node.nameToken));
      this.formatParenthesis(node.parenthesis);
    }
  }, {
    key: "formatArraySubscript",
    value: function formatArraySubscript(node) {
      this.layout.add(this.show(node.arrayToken));
      this.formatParenthesis(node.parenthesis);
    }
  }, {
    key: "formatParenthesis",
    value: function formatParenthesis(node) {
      var inline = this.inlineBlock.isInlineBlock(node);

      if (inline) {
        this.layout.add(node.openParen);
        this.layout = this.formatSubExpression(node.children, inline);
        this.layout.add(_Layout.WS.NO_SPACE, node.closeParen, _Layout.WS.SPACE);
      } else {
        this.layout.add(node.openParen, _Layout.WS.NEWLINE);

        if ((0, _config.isTabularStyle)(this.cfg)) {
          this.layout.add(_Layout.WS.INDENT);
          this.layout = this.formatSubExpression(node.children, inline);
        } else {
          this.layout.indentation.increaseBlockLevel();
          this.layout.add(_Layout.WS.INDENT);
          this.layout = this.formatSubExpression(node.children, inline);
          this.layout.indentation.decreaseBlockLevel();
        }

        this.layout.add(_Layout.WS.NEWLINE, _Layout.WS.INDENT, node.closeParen, _Layout.WS.SPACE);
      }
    }
  }, {
    key: "formatBetweenPredicate",
    value: function formatBetweenPredicate(node) {
      this.layout.add(this.show(node.betweenToken), _Layout.WS.SPACE);
      this.layout = this.formatSubExpression(node.expr1);
      this.layout.add(_Layout.WS.NO_SPACE, _Layout.WS.SPACE, this.showNonTabular(node.andToken), _Layout.WS.SPACE);
      this.layout = this.formatSubExpression(node.expr2);
      this.layout.add(_Layout.WS.SPACE);
    }
  }, {
    key: "formatClause",
    value: function formatClause(node) {
      if ((0, _config.isTabularStyle)(this.cfg)) {
        this.layout.add(_Layout.WS.NEWLINE, _Layout.WS.INDENT, this.show(node.nameToken), _Layout.WS.SPACE);
      } else {
        this.layout.add(_Layout.WS.NEWLINE, _Layout.WS.INDENT, this.show(node.nameToken), _Layout.WS.NEWLINE);
      }

      this.layout.indentation.increaseTopLevel();

      if (!(0, _config.isTabularStyle)(this.cfg)) {
        this.layout.add(_Layout.WS.INDENT);
      }

      this.layout = this.formatSubExpression(node.children);
      this.layout.indentation.decreaseTopLevel();
    }
  }, {
    key: "formatSetOperation",
    value: function formatSetOperation(node) {
      this.layout.add(_Layout.WS.NEWLINE, _Layout.WS.INDENT, this.show(node.nameToken), _Layout.WS.NEWLINE);
      this.layout.add(_Layout.WS.INDENT);
      this.layout = this.formatSubExpression(node.children);
    }
  }, {
    key: "formatLimitClause",
    value: function formatLimitClause(node) {
      this.layout.add(_Layout.WS.NEWLINE, _Layout.WS.INDENT, this.show(node.limitToken));
      this.layout.indentation.increaseTopLevel();

      if (node.offset) {
        this.layout.add(_Layout.WS.NEWLINE, _Layout.WS.INDENT);
        this.layout = this.formatSubExpression(node.offset);
        this.layout.add(_Layout.WS.NO_SPACE, ',', _Layout.WS.SPACE);
        this.layout = this.formatSubExpression(node.count);
      } else {
        this.layout.add(_Layout.WS.NEWLINE, _Layout.WS.INDENT);
        this.layout = this.formatSubExpression(node.count);
      }

      this.layout.indentation.decreaseTopLevel();
    }
  }, {
    key: "formatAllColumnsAsterisk",
    value: function formatAllColumnsAsterisk(_node) {
      this.layout.add('*', _Layout.WS.SPACE);
    }
  }, {
    key: "formatSubExpression",
    value: function formatSubExpression(nodes) {
      var inline = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.inline;
      return new ExpressionFormatter({
        cfg: this.cfg,
        params: this.params,
        layout: this.layout,
        inline: inline
      }).format(nodes);
    }
  }, {
    key: "formatToken",
    value: function formatToken(token) {
      switch (token.type) {
        case _token.TokenType.LINE_COMMENT:
          return this.formatLineComment(token);

        case _token.TokenType.BLOCK_COMMENT:
          return this.formatBlockComment(token);

        case _token.TokenType.RESERVED_JOIN:
          return this.formatJoin(token);

        case _token.TokenType.RESERVED_DEPENDENT_CLAUSE:
          return this.formatDependentClause(token);

        case _token.TokenType.AND:
        case _token.TokenType.OR:
        case _token.TokenType.XOR:
          return this.formatLogicalOperator(token);

        case _token.TokenType.RESERVED_KEYWORD:
        case _token.TokenType.RESERVED_FUNCTION_NAME:
        case _token.TokenType.RESERVED_PHRASE:
          return this.formatKeyword(token);

        case _token.TokenType.CASE:
          return this.formatCaseStart(token);

        case _token.TokenType.END:
          return this.formatCaseEnd(token);

        case _token.TokenType.COMMA:
          return this.formatComma(token);

        case _token.TokenType.OPERATOR:
        case _token.TokenType.ASTERISK:
          return this.formatOperator(token);

        case _token.TokenType.IDENTIFIER:
        case _token.TokenType.QUOTED_IDENTIFIER:
        case _token.TokenType.STRING:
        case _token.TokenType.NUMBER:
        case _token.TokenType.VARIABLE:
        case _token.TokenType.NAMED_PARAMETER:
        case _token.TokenType.QUOTED_PARAMETER:
        case _token.TokenType.NUMBERED_PARAMETER:
        case _token.TokenType.POSITIONAL_PARAMETER:
          return this.formatLiteral(token);

        default:
          throw new Error("Unexpected token type: ".concat(token.type));
      }
    }
    /** Default formatting for most token types */

  }, {
    key: "formatLiteral",
    value: function formatLiteral(token) {
      this.layout.add(this.show(token), _Layout.WS.SPACE);
    }
    /** Formats a line comment onto query */

  }, {
    key: "formatLineComment",
    value: function formatLineComment(token) {
      if (/\n/.test(token.precedingWhitespace || '')) {
        this.layout.add(_Layout.WS.NEWLINE, _Layout.WS.INDENT, this.show(token), _Layout.WS.MANDATORY_NEWLINE, _Layout.WS.INDENT);
      } else {
        this.layout.add(_Layout.WS.NO_NEWLINE, _Layout.WS.SPACE, this.show(token), _Layout.WS.MANDATORY_NEWLINE, _Layout.WS.INDENT);
      }
    }
    /** Formats a block comment onto query */

  }, {
    key: "formatBlockComment",
    value: function formatBlockComment(token) {
      var _this = this;

      this.splitBlockComment(token.text).forEach(function (line) {
        _this.layout.add(_Layout.WS.NEWLINE, _Layout.WS.INDENT, line);
      });
      this.layout.add(_Layout.WS.NEWLINE, _Layout.WS.INDENT);
    } // Breaks up block comment to multiple lines.
    // For example this comment (dots representing leading whitespace):
    //
    //   ..../**
    //   .....* Some description here
    //   .....* and here too
    //   .....*/
    //
    // gets broken to this array (note the leading single spaces):
    //
    //   [ '/**',
    //     '.* Some description here',
    //     '.* and here too',
    //     '.*/' ]
    //

  }, {
    key: "splitBlockComment",
    value: function splitBlockComment(comment) {
      return comment.split(/\n/).map(function (line) {
        if (/^\s*\*/.test(line)) {
          return ' ' + line.replace(/^\s*/, '');
        } else {
          return line.replace(/^\s*/, '');
        }
      });
    }
  }, {
    key: "formatJoin",
    value: function formatJoin(token) {
      if ((0, _config.isTabularStyle)(this.cfg)) {
        // in tabular style JOINs are at the same level as clauses
        this.layout.indentation.decreaseTopLevel();
        this.layout.add(_Layout.WS.NEWLINE, _Layout.WS.INDENT, this.show(token), _Layout.WS.SPACE);
        this.layout.indentation.increaseTopLevel();
      } else {
        this.layout.add(_Layout.WS.NEWLINE, _Layout.WS.INDENT, this.show(token), _Layout.WS.SPACE);
      }
    }
    /**
     * Formats a Reserved Keyword onto query
     */

  }, {
    key: "formatKeyword",
    value: function formatKeyword(token) {
      this.layout.add(this.show(token), _Layout.WS.SPACE);
    }
    /**
     * Formats a Reserved Dependent Clause token onto query, supporting the keyword that precedes it
     */

  }, {
    key: "formatDependentClause",
    value: function formatDependentClause(token) {
      this.layout.add(_Layout.WS.NEWLINE, _Layout.WS.INDENT, this.show(token), _Layout.WS.SPACE);
    }
    /**
     * Formats an Operator onto query, following rules for specific characters
     */

  }, {
    key: "formatOperator",
    value: function formatOperator(token) {
      // special operator
      if (token.text === ':') {
        this.layout.add(_Layout.WS.NO_SPACE, this.show(token), _Layout.WS.SPACE);
        return;
      } else if (token.text === '.' || token.text === '::') {
        this.layout.add(_Layout.WS.NO_SPACE, this.show(token));
        return;
      } // special case for PLSQL @ dblink syntax
      else if (token.text === '@' && this.cfg.language === 'plsql') {
        this.layout.add(_Layout.WS.NO_SPACE, this.show(token));
        return;
      } // other operators


      if (this.cfg.denseOperators) {
        this.layout.add(_Layout.WS.NO_SPACE, this.show(token));
      } else {
        this.layout.add(this.show(token), _Layout.WS.SPACE);
      }
    }
    /**
     * Formats a Logical Operator onto query, joining boolean conditions
     */

  }, {
    key: "formatLogicalOperator",
    value: function formatLogicalOperator(token) {
      if (this.cfg.logicalOperatorNewline === 'before') {
        if ((0, _config.isTabularStyle)(this.cfg)) {
          // In tabular style AND/OR is placed on the same level as clauses
          this.layout.indentation.decreaseTopLevel();
          this.layout.add(_Layout.WS.NEWLINE, _Layout.WS.INDENT, this.show(token), _Layout.WS.SPACE);
          this.layout.indentation.increaseTopLevel();
        } else {
          this.layout.add(_Layout.WS.NEWLINE, _Layout.WS.INDENT, this.show(token), _Layout.WS.SPACE);
        }
      } else {
        this.layout.add(this.show(token), _Layout.WS.NEWLINE, _Layout.WS.INDENT);
      }
    }
  }, {
    key: "formatCaseStart",
    value: function formatCaseStart(token) {
      this.layout.indentation.increaseBlockLevel();
      this.layout.add(this.show(token), _Layout.WS.NEWLINE, _Layout.WS.INDENT);
    }
  }, {
    key: "formatCaseEnd",
    value: function formatCaseEnd(token) {
      this.formatMultilineBlockEnd(token);
    }
  }, {
    key: "formatMultilineBlockEnd",
    value: function formatMultilineBlockEnd(token) {
      this.layout.indentation.decreaseBlockLevel();
      this.layout.add(_Layout.WS.NEWLINE, _Layout.WS.INDENT, this.show(token), _Layout.WS.SPACE);
    }
    /**
     * Formats a comma Operator onto query, ending line unless in an Inline Block
     */

  }, {
    key: "formatComma",
    value: function formatComma(token) {
      if (!this.inline) {
        this.layout.add(_Layout.WS.NO_SPACE, this.show(token), _Layout.WS.NEWLINE, _Layout.WS.INDENT);
      } else {
        this.layout.add(_Layout.WS.NO_SPACE, this.show(token), _Layout.WS.SPACE);
      }
    }
  }, {
    key: "show",
    value: function show(token) {
      if ((0, _tabularStyle.isTabularToken)(token)) {
        return (0, _tabularStyle["default"])(this.showToken(token), this.cfg.indentStyle);
      } else {
        return this.showToken(token);
      }
    } // Like show(), but skips tabular formatting

  }, {
    key: "showNonTabular",
    value: function showNonTabular(token) {
      return this.showToken(token);
    } // don't call this directly, always use show() or showNonTabular() instead.

  }, {
    key: "showToken",
    value: function showToken(token) {
      if ((0, _token.isReserved)(token)) {
        switch (this.cfg.keywordCase) {
          case 'preserve':
            return (0, _utils.equalizeWhitespace)(token.raw);

          case 'upper':
            return token.text;

          case 'lower':
            return token.text.toLowerCase();
        }
      } else if ((0, _token.isParameter)(token)) {
        return this.params.get(token);
      } else {
        return token.text;
      }
    }
  }]);

  return ExpressionFormatter;
}();

exports["default"] = ExpressionFormatter;
module.exports = exports.default;
//# sourceMappingURL=ExpressionFormatter.js.map