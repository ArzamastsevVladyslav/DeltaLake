{"version":3,"file":"Tokenizer.js","names":["WHITESPACE_REGEX","NULL_REGEX","toCanonicalKeyword","text","equalizeWhitespace","toUpperCase","Tokenizer","cfg","tokens","preprocess","quotedIdentRegex","regexFactory","createQuoteRegex","identTypes","REGEX_MAP","TokenType","IDENT","createIdentRegex","identChars","STRING","stringTypes","VARIABLE","variableTypes","createVariableRegex","RESERVED_KEYWORD","createReservedWordRegex","reservedKeywords","RESERVED_DEPENDENT_CLAUSE","reservedDependentClauses","RESERVED_LOGICAL_OPERATOR","reservedLogicalOperators","RESERVED_COMMAND","reservedCommands","RESERVED_BINARY_COMMAND","reservedBinaryCommands","RESERVED_JOIN","reservedJoins","RESERVED_JOIN_CONDITION","reservedJoinConditions","OPERATOR","createOperatorRegex","operators","OPEN_PAREN","createParenRegex","openParens","CLOSE_PAREN","closeParens","RESERVED_CASE_START","RESERVED_CASE_END","LINE_COMMENT","createLineCommentRegex","lineCommentTypes","BLOCK_COMMENT","NUMBER","PARAMETER","EOF","paramPatterns","excludePatternsWithoutRegexes","regex","createParameterRegex","namedParamTypes","createIdentPattern","paramChars","parseKey","v","slice","quotedParamTypes","createQuotePattern","getEscapedPlaceholderKey","key","quoteChar","numberedParamTypes","positionalParams","undefined","patterns","filter","p","input","index","token","length","whitespaceBefore","getWhitespace","getNextToken","Error","push","lastIndex","matches","match","previousToken","matchToken","matchQuotedIdentToken","matchPlaceholderToken","matchReservedWordToken","type","transform","id","value","replace","RegExp","escapeRegExp","matchReservedToken","tokenType"],"sources":["../../src/core/Tokenizer.ts"],"sourcesContent":["import { equalizeWhitespace, escapeRegExp, id } from 'src/utils';\n\nimport * as regexFactory from './regexFactory';\nimport { type Token, TokenType } from './token';\n\n// A note about regular expressions\n//\n// We're using a sticky flag \"y\" in all tokenizing regexes.\n// This works a bit like ^, anchoring the regex to the start,\n// but when ^ anchores the regex to the start of string (or line),\n// the sticky flag anchors it to search start position, which we\n// can change by setting RegExp.lastIndex.\n//\n// This allows us to avoid slicing off tokens from the start of input string\n// (which we used in the past) and just move the match start position forward,\n// which is much more performant on long strings.\n\nconst WHITESPACE_REGEX = /(\\s+)/uy;\nconst NULL_REGEX = /(?!)/uy; // zero-width negative lookahead, matches nothing\n\nconst toCanonicalKeyword = (text: string) => equalizeWhitespace(text.toUpperCase());\n\n/** Struct that defines how a SQL language can be broken into tokens */\ninterface TokenizerOptions {\n  // Main clauses that start new block, like: SELECT, FROM, WHERE, ORDER BY\n  reservedCommands: string[];\n  // Logical operator keywords, defaults to: [AND, OR]\n  reservedLogicalOperators?: string[];\n  // Keywords in CASE expressions that begin new line, like: WHEN, ELSE\n  reservedDependentClauses: string[];\n  // Keywords that create newline but no indentaion of their body.\n  // These contain set operations like UNION and INTERSECT\n  reservedBinaryCommands: string[];\n  // Various joins like LEFT OUTER JOIN\n  reservedJoins: string[];\n  // keywords used for JOIN conditions, defaults to: [ON, USING]\n  reservedJoinConditions?: string[];\n  // all other reserved words (not included to any of the above lists)\n  reservedKeywords: string[];\n  // Types of quotes to use for strings\n  stringTypes: regexFactory.QuoteType[];\n  // Types of quotes to use for quoted identifiers\n  identTypes: regexFactory.QuoteType[];\n  // Types of quotes to use for variables\n  variableTypes?: regexFactory.VariableType[];\n  // Open-parenthesis characters\n  openParens?: ('(' | '[' | '{')[];\n  // Close-parenthesis characters\n  closeParens?: (')' | ']' | '}')[];\n  // True to allow for positional \"?\" parameter placeholders\n  positionalParams?: boolean;\n  // Prefixes for numbered parameter placeholders to support, e.g. :1, :2, :3\n  numberedParamTypes?: ('?' | ':' | '$')[];\n  // Prefixes for named parameter placeholders to support, e.g. :name\n  namedParamTypes?: (':' | '@' | '$')[];\n  // Prefixes for quoted parameter placeholders to support, e.g. :\"name\"\n  // The type of quotes will depend on `identifierTypes` option.\n  quotedParamTypes?: (':' | '@' | '$')[];\n  // Line comment types to support, defaults to --\n  lineCommentTypes?: string[];\n  // Additional characters to support in identifiers\n  identChars?: regexFactory.IdentChars;\n  // Additional characters to support in named parameters\n  // Use this when parameters allow different characters from identifiers\n  // Defaults to `identChars`.\n  paramChars?: regexFactory.IdentChars;\n  // Additional multi-character operators to support, in addition to <=, >=, <>, !=\n  operators?: string[];\n  // Allows custom modifications on the token array.\n  // Called after the whole input string has been split into tokens.\n  // The result of this will be the output of the tokenizer.\n  preprocess?: (tokens: Token[]) => Token[];\n}\n\ninterface ParamPattern {\n  regex: RegExp;\n  parseKey: (s: string) => string;\n}\n\n/** Converts SQL language string into a token stream */\nexport default class Tokenizer {\n  private REGEX_MAP: Record<TokenType, RegExp>;\n  private quotedIdentRegex: RegExp;\n  private paramPatterns: ParamPattern[];\n  // The input SQL string to process\n  private input = '';\n  // Current position in string\n  private index = 0;\n\n  private preprocess = (tokens: Token[]) => tokens;\n\n  constructor(cfg: TokenizerOptions) {\n    if (cfg.preprocess) {\n      this.preprocess = cfg.preprocess;\n    }\n\n    this.quotedIdentRegex = regexFactory.createQuoteRegex(cfg.identTypes);\n\n    this.REGEX_MAP = {\n      [TokenType.IDENT]: regexFactory.createIdentRegex(cfg.identChars),\n      [TokenType.STRING]: regexFactory.createQuoteRegex(cfg.stringTypes),\n      [TokenType.VARIABLE]: cfg.variableTypes\n        ? regexFactory.createVariableRegex(cfg.variableTypes)\n        : NULL_REGEX,\n      [TokenType.RESERVED_KEYWORD]: regexFactory.createReservedWordRegex(\n        cfg.reservedKeywords,\n        cfg.identChars\n      ),\n      [TokenType.RESERVED_DEPENDENT_CLAUSE]: regexFactory.createReservedWordRegex(\n        cfg.reservedDependentClauses ?? [],\n        cfg.identChars\n      ),\n      [TokenType.RESERVED_LOGICAL_OPERATOR]: regexFactory.createReservedWordRegex(\n        cfg.reservedLogicalOperators ?? ['AND', 'OR'],\n        cfg.identChars\n      ),\n      [TokenType.RESERVED_COMMAND]: regexFactory.createReservedWordRegex(\n        cfg.reservedCommands,\n        cfg.identChars\n      ),\n      [TokenType.RESERVED_BINARY_COMMAND]: regexFactory.createReservedWordRegex(\n        cfg.reservedBinaryCommands,\n        cfg.identChars\n      ),\n      [TokenType.RESERVED_JOIN]: regexFactory.createReservedWordRegex(\n        cfg.reservedJoins,\n        cfg.identChars\n      ),\n      [TokenType.RESERVED_JOIN_CONDITION]: regexFactory.createReservedWordRegex(\n        cfg.reservedJoinConditions ?? ['ON', 'USING'],\n        cfg.identChars\n      ),\n      [TokenType.OPERATOR]: regexFactory.createOperatorRegex('+-/*%&|^><=.,;[]{}`:$@', [\n        '<>',\n        '<=',\n        '>=',\n        '!=',\n        ...(cfg.operators ?? []),\n      ]),\n      [TokenType.OPEN_PAREN]: regexFactory.createParenRegex(cfg.openParens ?? ['(']),\n      [TokenType.CLOSE_PAREN]: regexFactory.createParenRegex(cfg.closeParens ?? [')']),\n      [TokenType.RESERVED_CASE_START]: /(CASE)\\b/iuy,\n      [TokenType.RESERVED_CASE_END]: /(END)\\b/iuy,\n      [TokenType.LINE_COMMENT]: regexFactory.createLineCommentRegex(cfg.lineCommentTypes ?? ['--']),\n      [TokenType.BLOCK_COMMENT]: /(\\/\\*[^]*?(?:\\*\\/|$))/uy,\n      [TokenType.NUMBER]:\n        /(0x[0-9a-fA-F]+|0b[01]+|(-\\s*)?[0-9]+(\\.[0-9]*)?([eE][-+]?[0-9]+(\\.[0-9]+)?)?)/uy,\n      [TokenType.PARAMETER]: NULL_REGEX, // matches nothing\n      [TokenType.EOF]: NULL_REGEX, // matches nothing\n    };\n\n    this.paramPatterns = this.excludePatternsWithoutRegexes([\n      {\n        // :name placeholders\n        regex: regexFactory.createParameterRegex(\n          cfg.namedParamTypes ?? [],\n          regexFactory.createIdentPattern(cfg.paramChars || cfg.identChars)\n        ),\n        parseKey: v => v.slice(1),\n      },\n      {\n        // :\"name\" placeholders\n        regex: regexFactory.createParameterRegex(\n          cfg.quotedParamTypes ?? [],\n          regexFactory.createQuotePattern(cfg.identTypes)\n        ),\n        parseKey: v =>\n          this.getEscapedPlaceholderKey({ key: v.slice(2, -1), quoteChar: v.slice(-1) }),\n      },\n      {\n        // :1, :2, :3 placeholders\n        regex: regexFactory.createParameterRegex(cfg.numberedParamTypes ?? [], '[0-9]+'),\n        parseKey: v => v.slice(1),\n      },\n      {\n        // ? placeholders\n        regex: cfg.positionalParams ? /(\\?)/uy : undefined,\n        parseKey: v => v.slice(1),\n      },\n    ]);\n  }\n\n  private excludePatternsWithoutRegexes(\n    patterns: { regex?: RegExp; parseKey: (s: string) => string }[]\n  ) {\n    return patterns.filter((p): p is ParamPattern => p.regex !== undefined);\n  }\n\n  /**\n   * Takes a SQL string and breaks it into tokens.\n   * Each token is an object with type and value.\n   *\n   * @param {string} input - The SQL string\n   * @returns {Token[]} output token stream\n   */\n  public tokenize(input: string): Token[] {\n    this.input = input;\n    this.index = 0;\n    const tokens: Token[] = [];\n    let token: Token | undefined;\n\n    // Keep processing the string until end is reached\n    while (this.index < this.input.length) {\n      // grab any preceding whitespace\n      const whitespaceBefore = this.getWhitespace();\n\n      if (this.index < this.input.length) {\n        // Get the next token and the token type\n        token = this.getNextToken(token);\n        if (!token) {\n          throw new Error(`Parse error: Unexpected \"${input.slice(this.index, 100)}\"`);\n        }\n\n        tokens.push({ ...token, whitespaceBefore });\n      }\n    }\n    return this.preprocess(tokens);\n  }\n\n  private getWhitespace(): string {\n    WHITESPACE_REGEX.lastIndex = this.index;\n    const matches = this.input.match(WHITESPACE_REGEX);\n    if (matches) {\n      // Advance current position by matched whitespace length\n      this.index += matches[1].length;\n      return matches[1];\n    } else {\n      return '';\n    }\n  }\n\n  private getNextToken(previousToken?: Token): Token | undefined {\n    return (\n      this.matchToken(TokenType.LINE_COMMENT) ||\n      this.matchToken(TokenType.BLOCK_COMMENT) ||\n      this.matchToken(TokenType.STRING) ||\n      this.matchQuotedIdentToken() ||\n      this.matchToken(TokenType.VARIABLE) ||\n      this.matchToken(TokenType.OPEN_PAREN) ||\n      this.matchToken(TokenType.CLOSE_PAREN) ||\n      this.matchPlaceholderToken() ||\n      this.matchToken(TokenType.NUMBER) ||\n      this.matchReservedWordToken(previousToken) ||\n      this.matchToken(TokenType.IDENT) ||\n      this.matchToken(TokenType.OPERATOR)\n    );\n  }\n\n  private matchPlaceholderToken(): Token | undefined {\n    for (const { regex, parseKey } of this.paramPatterns) {\n      const token = this.match({\n        regex,\n        type: TokenType.PARAMETER,\n        transform: id,\n      });\n      if (token) {\n        return { ...token, key: parseKey(token.value) };\n      }\n    }\n    return undefined;\n  }\n\n  private getEscapedPlaceholderKey({ key, quoteChar }: { key: string; quoteChar: string }): string {\n    return key.replace(new RegExp(escapeRegExp('\\\\' + quoteChar), 'gu'), quoteChar);\n  }\n\n  private matchQuotedIdentToken(): Token | undefined {\n    return this.match({\n      regex: this.quotedIdentRegex,\n      type: TokenType.IDENT,\n      transform: id,\n    });\n  }\n\n  private matchReservedWordToken(previousToken?: Token): Token | undefined {\n    // A reserved word cannot be preceded by a '.'\n    // this makes it so in \"mytable.from\", \"from\" is not considered a reserved word\n    if (previousToken?.value === '.') {\n      return undefined;\n    }\n\n    // prioritised list of Reserved token types\n    return (\n      this.matchReservedToken(TokenType.RESERVED_CASE_START) ||\n      this.matchReservedToken(TokenType.RESERVED_CASE_END) ||\n      this.matchReservedToken(TokenType.RESERVED_COMMAND) ||\n      this.matchReservedToken(TokenType.RESERVED_BINARY_COMMAND) ||\n      this.matchReservedToken(TokenType.RESERVED_JOIN) ||\n      this.matchReservedToken(TokenType.RESERVED_DEPENDENT_CLAUSE) ||\n      this.matchReservedToken(TokenType.RESERVED_LOGICAL_OPERATOR) ||\n      this.matchReservedToken(TokenType.RESERVED_KEYWORD) ||\n      this.matchReservedToken(TokenType.RESERVED_JOIN_CONDITION)\n    );\n  }\n\n  // Helper for matching RESERVED_* tokens which need to be transformed to canonical form\n  private matchReservedToken(tokenType: TokenType): Token | undefined {\n    return this.match({\n      type: tokenType,\n      regex: this.REGEX_MAP[tokenType],\n      transform: toCanonicalKeyword,\n    });\n  }\n\n  // Shorthand for `match` that looks up regex from REGEX_MAP\n  private matchToken(tokenType: TokenType): Token | undefined {\n    return this.match({\n      type: tokenType,\n      regex: this.REGEX_MAP[tokenType],\n      transform: id,\n    });\n  }\n\n  // Attempts to match RegExp at current position in input\n  private match({\n    type,\n    regex,\n    transform,\n  }: {\n    type: TokenType;\n    regex: RegExp;\n    transform: (s: string) => string;\n  }): Token | undefined {\n    regex.lastIndex = this.index;\n    const matches = this.input.match(regex);\n    if (matches) {\n      // Advance current position by matched token length\n      this.index += matches[1].length;\n      return {\n        type,\n        text: matches[1],\n        value: transform(matches[1]),\n      };\n    }\n    return undefined;\n  }\n}\n"],"mappings":"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"}