{"version":3,"file":"regexFactory.js","names":["quotePatterns","createOperatorRegex","monadOperators","polyadOperators","patternToRegex","sortByLengthDesc","map","escapeRegExp","join","split","createLineCommentRegex","lineCommentTypes","RegExp","c","createReservedWordRegex","reservedKeywords","identChars","length","avoidIdentChars","rejectIdentCharsPattern","reservedKeywordsPattern","replace","rest","dashes","createIdentRegex","specialChars","createIdentPattern","first","letter","number","firstChars","restChars","pattern","withDashes","toCaseInsensitivePattern","prefix","char","toUpperCase","toLowerCase","prefixesPattern","prefixes","required","createSingleQuotePattern","type","quote","createQuotePattern","quoteTypes","createSingleVariablePattern","regex","createVariableRegex","varTypes","createQuoteRegex","escapeParen","paren","createParenRegex","parens","createParameterRegex","types","isEmpty","undefined","typesRegex"],"sources":["../../src/core/regexFactory.ts"],"sourcesContent":["import { escapeRegExp, isEmpty, sortByLengthDesc } from 'src/utils';\n\n// This enables the following quote styles:\n// 1. backtick quoted using `` to escape\n// 2. square bracket quoted (SQL Server) using ]] to escape\n// 3. double quoted using \"\" or \\\" to escape\n// 4. single quoted using '' or \\' to escape\n// 5. PostgreSQL dollar-quoted\n// 6. BigQuery '''triple-quoted'''\n// 7. BigQuery \"\"\"triple-quoted\"\"\"\n// 8. Hive and Spark variables: ${name}\nconst quotePatterns = {\n  '``': '(`[^`]*($|`))+',\n  '[]': '(\\\\[[^\\\\]]*($|\\\\]))(\\\\][^\\\\]]*($|\\\\]))*',\n  '\"\"': '(\"[^\"\\\\\\\\]*(?:\\\\\\\\.[^\"\\\\\\\\]*)*(\"|$))+',\n  \"''\": \"('[^'\\\\\\\\]*(?:\\\\\\\\.[^'\\\\\\\\]*)*('|$))+\",\n  '$$': '(?<tag>\\\\$\\\\w*\\\\$)[\\\\s\\\\S]*?(?:\\\\k<tag>|$)',\n  \"'''..'''\": \"'''[^\\\\\\\\]*?(?:\\\\\\\\.[^\\\\\\\\]*?)*?('''|$)\",\n  '\"\"\"..\"\"\"': '\"\"\"[^\\\\\\\\]*?(?:\\\\\\\\.[^\\\\\\\\]*?)*?(\"\"\"|$)',\n  '{}': '(\\\\{[^\\\\}]*($|\\\\}))',\n};\nexport type PlainQuoteType = keyof typeof quotePatterns;\n\nexport type PrefixedQuoteType = {\n  quote: PlainQuoteType;\n  prefixes: string[];\n  required?: boolean; // True when prefix is required\n};\n\nexport type QuoteType = PlainQuoteType | PrefixedQuoteType;\n\nexport interface VariableRegex {\n  regex: string;\n}\n\nexport type VariableType = VariableRegex | PrefixedQuoteType;\n\nexport interface IdentChars {\n  // Additional characters that can be used as first character of an identifier.\n  // That is: in addition to letters and underscore.\n  first?: string;\n  // Additional characters that can appear after the first character of identifier.\n  // That is: in addition to letters, numbers and underscore.\n  rest?: string;\n  // True to allow single dashes (-) inside identifiers, but not at the beginning or end\n  dashes?: boolean;\n}\n\n/**\n * Builds a RegExp containing all operators for a SQL dialect\n * @param {string} monadOperators - concatenated string of all 1-length operators\n * @param {string[]} polyadOperators - list of strings of all >1-length operators\n */\nexport const createOperatorRegex = (monadOperators: string, polyadOperators: string[]): RegExp =>\n  patternToRegex(\n    `${sortByLengthDesc(polyadOperators).map(escapeRegExp).join('|')}|` +\n      `[${monadOperators.split('').map(escapeRegExp).join('')}]`\n  );\n\n/**\n * Builds a RegExp for valid line comments in a SQL dialect\n * @param {string[]} lineCommentTypes - list of character strings that denote line comments\n */\nexport const createLineCommentRegex = (lineCommentTypes: string[]): RegExp =>\n  new RegExp(\n    `((?:${lineCommentTypes.map(c => escapeRegExp(c)).join('|')}).*?)(?:\\r\\n|\\r|\\n|$)`,\n    'uy'\n  );\n\n/**\n * Builds a RegExp for all Reserved Keywords in a SQL dialect\n */\nexport const createReservedWordRegex = (\n  reservedKeywords: string[],\n  identChars: IdentChars = {}\n): RegExp => {\n  if (reservedKeywords.length === 0) {\n    return /\\b$/uy;\n  }\n\n  const avoidIdentChars = rejectIdentCharsPattern(identChars);\n\n  const reservedKeywordsPattern = sortByLengthDesc(reservedKeywords)\n    .join('|')\n    .replace(/ /gu, '\\\\s+');\n\n  return new RegExp(`(${reservedKeywordsPattern})${avoidIdentChars}\\\\b`, 'iuy');\n};\n\n// Negative lookahead to avoid matching a keyword that's actually part of identifier,\n// which can happen when identifier allows word-boundary characters inside it.\n//\n// For example \"SELECT$ME\" should be tokenized as:\n// - [\"SELECT$ME\"] when $ is allowed inside identifiers\n// - [\"SELECT\", \"$\", \"ME\"] when $ can't be part of identifiers.\nconst rejectIdentCharsPattern = ({ rest, dashes }: IdentChars): string =>\n  rest || dashes ? `(?![${rest || ''}${dashes ? '-' : ''}])` : '';\n\n/**\n * Builds a RegExp for valid identifiers in a SQL dialect\n */\nexport const createIdentRegex = (specialChars: IdentChars = {}): RegExp =>\n  patternToRegex(createIdentPattern(specialChars));\n\n/**\n * Builds a RegExp string for valid identifiers in a SQL dialect\n */\nexport const createIdentPattern = ({ first, rest, dashes }: IdentChars = {}): string => {\n  // Unicode letters, diacritical marks and underscore\n  const letter = '\\\\p{Alphabetic}\\\\p{Mark}_';\n  // Numbers 0..9, plus various unicode numbers\n  const number = '\\\\p{Decimal_Number}';\n\n  const firstChars = escapeRegExp(first ?? '');\n  const restChars = escapeRegExp(rest ?? '');\n\n  const pattern = `[${letter}${firstChars}][${letter}${number}${restChars}]*`;\n\n  return dashes ? withDashes(pattern) : pattern;\n};\n\nconst withDashes = (pattern: string): string => pattern + '(?:-' + pattern + ')*';\n\n// Converts \"ab\" to \"[Aa][Bb]\"\nconst toCaseInsensitivePattern = (prefix: string): string =>\n  prefix\n    .split('')\n    .map(char => '[' + char.toUpperCase() + char.toLowerCase() + ']')\n    .join('');\n\n// Converts [\"a\", \"b\"] to \"(?:[Aa]|[Bb]|)\" or \"(?:[Aa]|[Bb])\" when required = true\nconst prefixesPattern = ({ prefixes, required }: PrefixedQuoteType): string =>\n  '(?:' + prefixes.map(toCaseInsensitivePattern).join('|') + (required ? '' : '|') + ')';\n\nconst createSingleQuotePattern = (type: QuoteType): string => {\n  if (typeof type === 'string') {\n    return quotePatterns[type];\n  } else {\n    return prefixesPattern(type) + quotePatterns[type.quote];\n  }\n};\n\n/** Builds a quote-delimited pattern for matching all given quote types */\nexport const createQuotePattern = (quoteTypes: QuoteType[]): string =>\n  quoteTypes.map(createSingleQuotePattern).join('|');\n\nconst createSingleVariablePattern = (type: VariableType): string => {\n  if ('regex' in type) {\n    return type.regex;\n  } else {\n    return createSingleQuotePattern(type);\n  }\n};\n\n/** Builds a RegExp for matching variables */\nexport const createVariableRegex = (varTypes: VariableType[]): RegExp =>\n  patternToRegex(varTypes.map(createSingleVariablePattern).join('|'));\n\n/** Builds a RegExp for matching quote-delimited patterns */\nexport const createQuoteRegex = (quoteTypes: QuoteType[]): RegExp =>\n  patternToRegex(createQuotePattern(quoteTypes));\n\n/** Escapes paren characters for RegExp patterns */\nconst escapeParen = (paren: string): string => {\n  if (paren.length === 1) {\n    // A single punctuation character\n    return escapeRegExp(paren);\n  } else {\n    // longer word\n    return '\\\\b' + paren + '\\\\b';\n  }\n};\n\n/**\n * Builds a RegExp for matching parenthesis patterns, escaping them with `escapeParen`\n * @param {string[]} parens - list of strings that denote parenthesis patterns\n */\nexport const createParenRegex = (parens: string[]): RegExp =>\n  patternToRegex(parens.map(escapeParen).join('|'));\n\n/**\n * Builds a RegExp for parameter placeholder patterns\n * @param {string[]} types - list of strings that denote placeholder types\n * @param {string} pattern - string that denotes placeholder pattern\n */\nexport const createParameterRegex = (types: string[], pattern: string): RegExp | undefined => {\n  if (isEmpty(types)) {\n    return undefined;\n  }\n  const typesRegex = types.map(escapeRegExp).join('|');\n\n  return patternToRegex(`(?:${typesRegex})(?:${pattern})`);\n};\n\nconst patternToRegex = (pattern: string): RegExp => new RegExp('(' + pattern + ')', 'uy');\n"],"mappings":"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"}